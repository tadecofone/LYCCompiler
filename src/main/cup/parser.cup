package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.tree.GestorNodos;
import lyc.compiler.table.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;
import java.util.List;
import lyc.compiler.tree.ASTManager;
import java.math.*;
import lyc.compiler.files.*;
import java.io.IOException;


class Parser;

action code {:

  // Variables globales y métodos para la clase Parser

  ASTManager astManager;
  IntermediateCodeGenerator intermediateCodeGenerator;
  GestorNodos gestorNodos;
  HashMap<String, SymbolEntry> symbolTable = SymbolTableManager.symbolTable;
  List<String> idList = new ArrayList<>();
  Stack<Integer> conditionStack = new Stack<>();
  Stack<Integer> trueStack = new Stack<>();
  Stack<Integer> falseStack = new Stack<>();
  Stack<Integer> auxExpressionStack = new Stack<>();
  Stack<Integer> auxTermStack = new Stack<>();

  DataType dataType;

      //Indices:
      int expressionIdx;
      int termIdx;
      int factorIdx;
      int programIdx;
      int blockIdx;
      int sentenceIdx;
      int vardeclarationIdx;
      int varsentenceIdx;
      int datatypeIdx;
      int idlistIdx;
      int decitionIdx;
      int conditionIdx;
      int comparisonIdx;
      int comparatorIdx;
      int iterationIdx;
      int assigIdx;
      int s_writeIdx;
      int s_readIdx;
      int write_paramIdx;
      int read_paramIdx;
      int sum_first_primesIdx;
      int negative_calculationIdx;
      int c_listIdx;
      int listIdx;
      int cuerpoIdx;
      int cizquierdoIdx;
      int auxcmpIdx;
      String comparator;

      //Para Negative calculations:
      int c;
      int sum;
      int mult;
      int auxnc;
      int auxncIdx;
      int ifIdx;
      int auxcondIdx;
      int auxnc2Idx;
      int auxnc3Idx;

:}

// TERMINALS
terminal ASSIG, PLUS, SUB, MULT, DIV, REST, MAYOR, LOWER, MAYOR_I, LOWER_I, EQUAL, NOT_EQUAL;
terminal AND_COND, OR_COND, NOT_COND, OPEN_BRACKET, CLOSE_BRACKET, OPEN_CURLY_BRACKET, CLOSE_CURLY_BRACKET, OPEN_SQUARE_BRACKET, CLOSE_SQUARE_BRACKET;
terminal COMMA, SEMI_COLON, DOT, DOUBLE_DOT, INTEGER_CONSTANT, FLOAT_CONSTANT, STRING_CONSTANT;
terminal INT, FLOAT, STRING, IF, ELSE, WHILE, WRITE, READ;
terminal String IDENTIFIER;
terminal INIT, NEGATIVE_CALCULATION, SUM_FIRST_PRIMES;

// NON TERMINALS (devuelven Integer, el índice del nodo)
non terminal program, block, sentence, var_declaration, var_sencente_dec, data_type, id_list;
non terminal decition, condition, comparison, comparator, iterator, assignment;
non terminal s_write, s_read, write_param, read_param, expression, term, factor;
non terminal negative_calculation, sum_first_primes, c_list, list;

// Start Symbol Definition
start with program;

program ::= block:b {:
    System.out.println("Compilation Ok");
    ASTManager.setRoot(blockIdx);
    //Imprimir arbol por consola
    GestorNodos.imprimirArbol(blockIdx);
    //Generar .dot para ver visualmente el arbol en pdf
    IntermediateCodeGenerator.generarDot("salida.dot",GestorNodos.obtenerNodo(blockIdx));

    //llamar a genera codigo assembler
        try {
            AsmCodeGenerator.generateAssembler("salida.asm", blockIdx);
        } catch (IOException e) {
            e.printStackTrace();
        }


:};

/*-----------------------------------------
   BLOCK
-----------------------------------------*/
block ::= sentence:s
        {:
          blockIdx = sentenceIdx;
        :}
        | block:bk sentence:s
        {:
          System.out.println("Nueva sentencia en block");
          blockIdx = GestorNodos.crearNodo(";", blockIdx, sentenceIdx);
        :};

/*-----------------------------------------
   SENTENCE
-----------------------------------------*/
sentence ::= INIT OPEN_CURLY_BRACKET var_declaration CLOSE_CURLY_BRACKET
           {:
             System.out.println("Variable declaration ends");
             sentenceIdx = vardeclarationIdx;
           :}
           | decition:d
           {:
             sentenceIdx = decitionIdx;
           :}
           | iterator:i
           {:
             sentenceIdx = iterationIdx;
           :}
           | assignment:a
           {:
             System.out.println("Asignación detectada");
             sentenceIdx = assigIdx;
           :}
           | s_write:sw
           {:
             sentenceIdx = s_writeIdx;
           :}
           | s_read:sr
           {:
             sentenceIdx = s_readIdx;
           :}
           | sum_first_primes:sf
           {:
             sentenceIdx = sum_first_primesIdx;
           :}
           | negative_calculation:nc
           {:
             sentenceIdx = negative_calculationIdx;
           :};

/*-----------------------------------------
   VAR DECLARATION
-----------------------------------------*/
var_declaration ::= var_declaration var_sencente_dec
        {:
            vardeclarationIdx = GestorNodos.crearNodo(";", vardeclarationIdx, varsentenceIdx);

        :};

var_declaration ::= var_sencente_dec
        {:
            vardeclarationIdx = varsentenceIdx;

        :};
var_sencente_dec ::= id_list DOUBLE_DOT data_type
  {:
    for (String id : idList) {
      SymbolTableManager.setDataTypeInTable(id, dataType);
    }
    idList.clear();
    varsentenceIdx = GestorNodos.crearNodo(":",idlistIdx, GestorNodos.crearNodo(dataType.getName()));

  :};

data_type ::= INT
  {:
    System.out.println("Int data type");
    dataType = DataType.INTEGER_TYPE;
  :}
  | FLOAT
  {:
    System.out.println("Float data type");
    dataType = DataType.FLOAT_TYPE;
  :}
  | STRING
  {:
    System.out.println("String data type");
    dataType = DataType.STRING_TYPE;
  :};

id_list ::= id_list COMMA IDENTIFIER:id
  {:
    System.out.println("ID declared: " + id);
    idList.add(id);
    idlistIdx = GestorNodos.crearNodo(",",idlistIdx,GestorNodos.crearNodo(id));
  :};
id_list ::= IDENTIFIER:id
  {:
    System.out.println("ID declared: " + id);
    idList.add(id);
    idlistIdx = GestorNodos.crearNodo(id);
  :};

/*-----------------------------------------
   IF / ELSE
-----------------------------------------*/
decition ::= IF OPEN_BRACKET condition:c {: conditionStack.push(conditionIdx); :} CLOSE_BRACKET OPEN_CURLY_BRACKET block:b CLOSE_CURLY_BRACKET
  {:
    System.out.println("If statement");
    int x = conditionStack.pop();
    decitionIdx = GestorNodos.crearNodo("if", x, blockIdx);
  :};

/*decition ::= IF OPEN_BRACKET condition:c {: conditionStack.push(conditionIdx); :} CLOSE_BRACKET OPEN_CURLY_BRACKET block:b1 {: trueStack.push(blockIdx); :} CLOSE_CURLY_BRACKET ELSE OPEN_CURLY_BRACKET block:b2 {:  falseStack.push(blockIdx); :} CLOSE_CURLY_BRACKET
  {:
    System.out.println("If else statement");
    int y = trueStack.pop();
    int z = falseStack.pop();
    int x = conditionStack.pop();
    cuerpoIdx = GestorNodos.crearNodo("cuerpo", y, z);
    decitionIdx = GestorNodos.crearNodo("if", x, cuerpoIdx);
  :};

/*-----------------------------------------
   CONDITION
-----------------------------------------*/
condition ::= comparison:c1 {: auxcmpIdx = comparisonIdx; :} AND_COND comparison:c2
  {:
    System.out.println("And condition");
    conditionIdx = GestorNodos.crearNodo("AND", auxcmpIdx, comparisonIdx);
  :};
condition ::= comparison:c1 {: auxcmpIdx = comparisonIdx; :} OR_COND comparison:c2
  {:
    System.out.println("Or condition");
    conditionIdx = GestorNodos.crearNodo("OR", auxcmpIdx, comparisonIdx);

  :};
condition ::= comparison:c
  {:
    conditionIdx = comparisonIdx;
  :};
condition ::= NOT_COND comparison:c
  {:
    conditionIdx = GestorNodos.crearNodo("NOT", comparisonIdx);
  :};

/*-----------------------------------------
   COMPARISON
-----------------------------------------*/
comparison ::= expression:e1 {: cizquierdoIdx = expressionIdx; :} comparator:op expression:e2
  {:
    System.out.println("Comparison detectada con op: " + op);
    comparisonIdx = GestorNodos.crearNodo(comparator, cizquierdoIdx, expressionIdx);
  :}
  | OPEN_BRACKET condition:c CLOSE_BRACKET
  {:

  :};

comparator ::= MAYOR     {: comparator = ">"; :}
             | LOWER     {: comparator = "<"; :}
             | MAYOR_I   {: comparator = ">="; :}
             | LOWER_I   {: comparator = "<="; :}
             | EQUAL     {: comparator = "=="; :}
             | NOT_EQUAL {: comparator = "!="; :};

/*-----------------------------------------
   WHILE
-----------------------------------------*/
iterator ::= WHILE OPEN_BRACKET condition:c {: conditionStack.push(conditionIdx); :} CLOSE_BRACKET OPEN_CURLY_BRACKET block:b CLOSE_CURLY_BRACKET
  {:
    System.out.println("While statement");
    int x = conditionStack.pop();
    iterationIdx = GestorNodos.crearNodo("while", x, blockIdx);
  :};

/*-----------------------------------------
   ASSIGNMENT
-----------------------------------------*/
assignment ::= IDENTIFIER:id ASSIG expression:e
  {:
    System.out.println("Asignación: " + id + " := (nodo " + e + ")");
    assigIdx = GestorNodos.crearNodo("=", GestorNodos.crearNodo(id), expressionIdx);
  :}
  | IDENTIFIER:id ASSIG STRING_CONSTANT:stre
  {:
    // Asignar un string,
    // ej "=", nodo(id), nodo(str)
    assigIdx = GestorNodos.crearNodo("=", GestorNodos.crearNodo(id), GestorNodos.crearNodo((String) stre));
  :};

/*-----------------------------------------
   EXPRESSION
-----------------------------------------*/
expression ::= expression:e {: auxExpressionStack.push(expressionIdx); :} PLUS term:t
  {:
    System.out.println("Suma detectada: e=" + e + ", t=" + t);
    int x = auxExpressionStack.pop();
    expressionIdx = GestorNodos.crearNodo("+", x, termIdx);
  :}
  | expression:e {: auxExpressionStack.push(expressionIdx); :} SUB term:t
  {:
    System.out.println("Resta detectada: e=" + e + ", t=" + t);
     int x = auxExpressionStack.pop();
    expressionIdx = GestorNodos.crearNodo("-", x, termIdx);
  :}
  | term:t
  {:
    expressionIdx = termIdx;
  :};

/*-----------------------------------------
   TERM
-----------------------------------------*/
term ::= term:tt {: auxTermStack.push(termIdx); :} MULT factor:ff
  {:
    System.out.println("Multiplicación detectada: tt=" + tt + " ff=" + ff);
    int x = auxTermStack.pop();
    termIdx = GestorNodos.crearNodo("*", x, factorIdx);
  :}
  | term:tt {: auxTermStack.push(termIdx); :} DIV factor:ff
  {:
    System.out.println("División detectada: tt=" + tt + " ff=" + ff);
    int x = auxTermStack.pop();
    termIdx = GestorNodos.crearNodo("/", x, factorIdx);
  :}
  | factor:f
  {:
    termIdx = factorIdx;
  :};

/*-----------------------------------------
   FACTOR
-----------------------------------------*/
factor ::= IDENTIFIER:id
  {:
    System.out.println("Id: " + id);
    factorIdx = GestorNodos.crearNodo(id);
  :}
  | INTEGER_CONSTANT:constant
  {:
    System.out.println("Integer constant: " + constant);
    factorIdx = GestorNodos.crearNodo(constant.toString());
  :}
  | FLOAT_CONSTANT:constant
  {:
    System.out.println("Float constant: " + constant);
    factorIdx = GestorNodos.crearNodo(constant.toString());
  :}
  | OPEN_BRACKET expression:e CLOSE_BRACKET
  {:
    factorIdx = expressionIdx;
  :};

/*-----------------------------------------
   NEGATIVE_CALCULATION
-----------------------------------------*/
negative_calculation ::= IDENTIFIER:id ASSIG NEGATIVE_CALCULATION OPEN_BRACKET c_list CLOSE_BRACKET
  {:
     System.out.println("negative-calculation function");

    negative_calculationIdx = GestorNodos.crearNodo("%",GestorNodos.crearNodo("@c"),GestorNodos.crearNodo("2"));
    auxcondIdx = GestorNodos.crearNodo("==",negative_calculationIdx,GestorNodos.crearNodo("0"));

    auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo(id),GestorNodos.crearNodo("@sum"));
    auxnc2Idx = GestorNodos.crearNodo("=",GestorNodos.crearNodo(id),GestorNodos.crearNodo("@mult"));

    auxncIdx = GestorNodos.crearNodo("cuerpo",auxncIdx, auxnc2Idx);

    negative_calculationIdx = GestorNodos.crearNodo("if",auxcondIdx, auxncIdx);

    negative_calculationIdx = GestorNodos.crearNodo(";",c_listIdx, negative_calculationIdx);

  :};

c_list ::= c_list COMMA list
  {:
            auxcondIdx = GestorNodos.crearNodo("<",GestorNodos.crearNodo("@aux"),GestorNodos.crearNodo("0"));
            auxncIdx = GestorNodos.crearNodo("+",GestorNodos.crearNodo("@c"),GestorNodos.crearNodo("1"));
            auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@c"),auxncIdx);
            auxnc2Idx = GestorNodos.crearNodo("*",GestorNodos.crearNodo("@mult"),GestorNodos.crearNodo("@aux"));
            auxnc2Idx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@mult"),auxnc2Idx);
            auxnc3Idx = GestorNodos.crearNodo("+",GestorNodos.crearNodo("@sum"),GestorNodos.crearNodo("@aux"));
            auxnc3Idx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@sum"),auxnc3Idx);

            auxnc2Idx = GestorNodos.crearNodo(";",auxnc2Idx,auxnc3Idx);
            auxncIdx = GestorNodos.crearNodo(";",auxncIdx,auxnc2Idx);
            ifIdx = GestorNodos.crearNodo("if",auxcondIdx,auxncIdx);

            c_listIdx = GestorNodos.crearNodo(";",c_listIdx,ifIdx);

  :};
c_list ::= list
  {:

        c_listIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@auxnc"),listIdx);
        auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@c"),GestorNodos.crearNodo("0"));
        c_listIdx = GestorNodos.crearNodo(";",c_listIdx,auxncIdx);
        auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@mult"),GestorNodos.crearNodo("1"));
        c_listIdx = GestorNodos.crearNodo(";",c_listIdx,auxncIdx);
        auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@sum"),GestorNodos.crearNodo("0"));
        c_listIdx = GestorNodos.crearNodo(";",c_listIdx,auxncIdx);

        auxcondIdx = GestorNodos.crearNodo("<",GestorNodos.crearNodo("@aux"),GestorNodos.crearNodo("0"));
        auxncIdx = GestorNodos.crearNodo("+",GestorNodos.crearNodo("@c"),GestorNodos.crearNodo("1"));
        auxncIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@c"),auxncIdx);
        auxnc2Idx = GestorNodos.crearNodo("*",GestorNodos.crearNodo("@mult"),GestorNodos.crearNodo("@aux"));
        auxnc2Idx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@mult"),auxnc2Idx);
        auxnc3Idx = GestorNodos.crearNodo("+",GestorNodos.crearNodo("@sum"),GestorNodos.crearNodo("@aux"));
        auxnc3Idx = GestorNodos.crearNodo("=",GestorNodos.crearNodo("@sum"),auxnc3Idx);

        auxnc2Idx = GestorNodos.crearNodo(";",auxnc2Idx,auxnc3Idx);
        auxncIdx = GestorNodos.crearNodo(";",auxncIdx,auxnc2Idx);
        ifIdx = GestorNodos.crearNodo("if",auxcondIdx,auxncIdx);

        c_listIdx = GestorNodos.crearNodo(";",c_listIdx,ifIdx);


  :};

list ::= IDENTIFIER:id
  {: System.out.println("Id: " + id);
    listIdx = GestorNodos.crearNodo(id);

  :};
list ::= FLOAT_CONSTANT:constant
  {:
    System.out.println("Float constant: " + constant);
    listIdx = GestorNodos.crearNodo((String) constant);

  :};

/*-----------------------------------------
   sum_first_primes
-----------------------------------------*/
sum_first_primes ::= IDENTIFIER:id ASSIG SUM_FIRST_PRIMES OPEN_BRACKET INTEGER_CONSTANT:num CLOSE_BRACKET {:
    System.out.println("sum-first-primes function");

    int n = Integer.parseInt(num.toString());
        if(n <= 0) {
             throw new Exception("Error semántico: sumFirstPrimes requiere un valor mayor que 0, se recibió: " + n);
            }
    int aux = 0;
    int aux2 = 2;
    int sum = 0;
    while (aux < n) {
     if(BigInteger.valueOf(aux2).isProbablePrime(20)) {
        sum+=aux2;
        aux++;
      }
      aux2++;
    }
    sum_first_primesIdx = GestorNodos.crearNodo("=",GestorNodos.crearNodo(id),GestorNodos.crearNodo(Integer.toString(sum)));
   // ASTManager.sum_first_primesIdx.setNode(new Node("=", new Node(id), new Node(sum) ));
:};

/*-----------------------------------------
   WRITE / READ
-----------------------------------------*/
s_write ::= WRITE OPEN_BRACKET write_param CLOSE_BRACKET
  {:
    System.out.println("Write statement");

  :};

write_param ::= STRING_CONSTANT
  {:
  :}
  | IDENTIFIER:id
  {:
    System.out.println("Write parameter: " + id);
  :};

s_read ::= READ OPEN_BRACKET read_param CLOSE_BRACKET
  {:
    System.out.println("Read statement");
  :};

read_param ::= IDENTIFIER:id
  {:
    System.out.println("Read parameter: " + id);
  :};
